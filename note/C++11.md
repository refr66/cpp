C++11 是 C++ 语言的一次重大更新，引入了许多现代编程语言特性，大幅提升了代码简洁性、安全性和性能。以下是 **C++11 核心知识点汇总**，按类别整理：


### **一、语法糖与便捷特性**
#### 1. **统一初始化与初始化列表（Uniform Initialization）**
   - 支持用 `{}` 初始化任意类型（替代 `()` 和 `=`），避免窄化转换：
     ```cpp
     int a{10};          // 正确
     int b{3.14};        // 编译错误（窄化转换）
     std::vector<int> v{1, 2, 3};  // 容器初始化
     struct Point { int x, y; };
     Point p{1, 2};      // 结构体初始化
     ```
   - 引入 `std::initializer_list`，允许函数接收初始化列表参数：
     ```cpp
     void func(std::initializer_list<int> list) {
         for (auto x : list) std::cout << x;
     }
     func({1, 2, 3});  // 调用
     ```


#### 2. **类型推导（Type Deduction）**
   - **`auto` 关键字**：让编译器自动推导变量类型（需初始化）：
     ```cpp
     auto i = 10;          // int
     auto s = "hello";     // const char*
     auto v = std::vector<int>{1,2,3};  // std::vector<int>
     ```
   - **`decltype` 关键字**：推导表达式的类型（不执行表达式）：
     ```cpp
     int x = 10;
     decltype(x) y = 20;   // y 类型为 int
     decltype(x + y) z;    // z 类型为 int（x+y 未执行）
     ```
   - **`decltype(auto)`**（C++14 扩展，C++11 中可模拟）：结合 `auto` 和 `decltype` 推导返回值类型。


#### 3. **范围 for 循环（Range-based for Loop）**
   - 简化容器/数组遍历，语法：`for (元素类型 变量 : 容器)`：
     ```cpp
     std::vector<int> v{1, 2, 3};
     for (int x : v) std::cout << x;       // 值遍历
     for (int& x : v) x *= 2;              // 引用遍历（修改元素）
     for (const auto& x : v) std::cout << x;  // 只读引用（高效）
     ```


#### 4. **nullptr 与 constexpr**
   - **`nullptr`**：空指针常量，替代 `NULL`（避免 `NULL` 被解释为整数 0 的歧义）：
     ```cpp
     void func(int);
     void func(char*);
     func(NULL);      // 歧义（调用 func(int)）
     func(nullptr);   // 正确调用 func(char*)
     ```
   - **`constexpr`**：编译期常量表达式，可用于定义编译期计算的变量或函数：
     ```cpp
     constexpr int MAX = 100;  // 编译期常量
     constexpr int add(int a, int b) { return a + b; }
     constexpr int val = add(3, 4);  // 编译期计算为 7
     ```


### **二、面向对象增强**
#### 1. **智能指针（Smart Pointers）**
   - 自动管理动态内存，避免内存泄漏，位于 `<memory>` 头文件：
     - **`std::unique_ptr`**：独占所有权，不可复制，可移动：
       ```cpp
       std::unique_ptr<int> p1(new int(10));
       std::unique_ptr<int> p2 = std::move(p1);  // 所有权转移（p1 变为 null）
       ```
     - **`std::shared_ptr`**：共享所有权，引用计数管理生命周期：
       ```cpp
       std::shared_ptr<int> p1(new int(10));
       std::shared_ptr<int> p2 = p1;  // 引用计数变为 2
       // 最后一个 shared_ptr 销毁时，内存自动释放
       ```
     - **`std::weak_ptr`**：弱引用，不增加引用计数，解决 `shared_ptr` 循环引用问题：
       ```cpp
       std::shared_ptr<A> a(new A);
       std::shared_ptr<B> b(new B);
       a->b = b;
       b->a = a;  // 循环引用（内存泄漏）
       // 解决：将 a->b 或 b->a 改为 weak_ptr
       ```


#### 2. **右值引用与移动语义（Rvalue References & Move Semantics）**
   - **右值引用（`&&`）**：绑定到临时对象（右值），支持移动操作：
     ```cpp
     int&& r = 10;  // 右值引用绑定到临时对象
     ```
   - **移动构造函数与移动赋值运算符**：避免临时对象的深拷贝，提升性能：
     ```cpp
     class MyString {
     public:
         // 移动构造（窃取右值对象的资源）
         MyString(MyString&& other) noexcept 
             : data(other.data), size(other.size) {
             other.data = nullptr;  // 原对象资源被转移
         }
         // 移动赋值
         MyString& operator=(MyString&& other) noexcept {
             if (this != &other) {
                 delete[] data;
                 data = other.data;
                 size = other.size;
                 other.data = nullptr;
             }
             return *this;
         }
     private:
         char* data;
         size_t size;
     };
     ```
   - **`std::move`**：将左值转换为右值引用，触发移动语义：
     ```cpp
     MyString s1("hello");
     MyString s2 = std::move(s1);  // 调用移动构造（s1 变为无效状态）
     ```


#### 3. **删除函数与默认函数（Deleted & Defaulted Functions）**
   - **删除函数（`= delete`）**：显式禁用某些函数（如拷贝构造）：
     ```cpp
     class NonCopyable {
     public:
         NonCopyable(const NonCopyable&) = delete;  // 禁用拷贝构造
         NonCopyable& operator=(const NonCopyable&) = delete;  // 禁用拷贝赋值
     };
     ```
   - **默认函数（`= default`）**：显式生成编译器默认版本（如默认构造函数）：
     ```cpp
     class MyClass {
     public:
         MyClass() = default;  // 编译器生成默认构造函数
         MyClass(int x) : x(x) {}  // 自定义构造函数（默认构造需显式 default）
     private:
         int x;
     };
     ```


#### 4. **委托构造函数（Delegating Constructors）**
   - 允许构造函数调用同一类的其他构造函数，简化代码：
     ```cpp
     class MyClass {
     public:
         MyClass() : MyClass(0) {}  // 委托给 MyClass(int)
         MyClass(int x) : x(x) {}
     private:
         int x;
     };
     ```


### **三、模板与泛型编程**
#### 1. **类型别名模板（Alias Templates）**
   - 简化复杂模板类型的命名：
     ```cpp
     template <typename T>
     using Vec = std::vector<T>;  // 别名模板
     Vec<int> v{1, 2, 3};  // 等价于 std::vector<int>
     ```


#### 2. **模板右值引用与完美转发（Perfect Forwarding）**
   - **万能引用（`T&&`）**：结合模板推导，可接收左值或右值：
     ```cpp
     template <typename T>
     void func(T&& t) {  // 万能引用（左值引用/右值引用取决于实参）
         // ...
     }
     ```
   - **`std::forward`**：完美转发，保持原始参数的左值/右值属性：
     ```cpp
     template <typename T>
     void wrapper(T&& t) {
         func(std::forward<T>(t));  // 转发 t 的原始类型（左值/右值）
     }
     ```


#### 3. **变长参数模板（Variadic Templates）**
   - 支持任意数量和类型的模板参数，用于实现泛型函数（如 `std::tuple`、`printf` 风格函数）：
     ```cpp
     // 递归终止函数
     void print() {}
     // 变长参数模板函数
     template <typename T, typename... Args>
     void print(const T& first, const Args&... args) {
         std::cout << first << " ";
         print(args...);  // 递归展开参数包
     }
     print(1, "hello", 3.14);  // 输出：1 hello 3.14
     ```


### **四、STL 增强**
#### 1. **新容器**
   - **`std::array`**：固定大小数组，结合 C 数组性能与 STL 容器接口：
     ```cpp
     std::array<int, 3> arr{1, 2, 3};
     arr.size();  // 编译期已知（3）
     arr[0] = 10;
     ```
   - **`std::unordered_map`/`std::unordered_set`**：哈希表实现，平均 O(1) 查找效率（区别于 `map`/`set` 的红黑树 O(log n)）。
   - **`std::tuple`**：元组，可存储不同类型的数据：
     ```cpp
     std::tuple<int, std::string, double> t(1, "hello", 3.14);
     int a = std::get<0>(t);  // 获取第 0 个元素（1）
     auto [x, y, z] = t;      // C++17 结构化绑定（更简洁）
     ```
   - **`std::forward_list`**：单向链表，替代 `std::list`（更高效的内存使用）。


#### 2. **算法与函数对象**
   - **`std::lambda` 表达式**：匿名函数，简化函数对象定义，语法：
     `[捕获列表](参数列表) mutable -> 返回类型 { 函数体 }`
     ```cpp
     int x = 10;
     auto add = [x](int y) { return x + y; };  // 捕获 x（值捕获）
     std::cout << add(5);  // 15
   
     // 用于 STL 算法
     std::vector<int> v{3, 1, 2};
     std::sort(v.begin(), v.end(), [](int a, int b) { return a > b; });  // 降序排序
     ```
   - **`std::function`**：可调用对象包装器，统一函数指针、lambda、函数对象等类型：
     ```cpp
     #include <functional>
     std::function<int(int, int)> add = [](int a, int b) { return a + b; };
     add(3, 4);  // 7
     ```
   - **`std::bind`**：绑定函数参数，生成新的可调用对象：
     ```cpp
     int add(int a, int b) { return a + b; }
     auto add5 = std::bind(add, 5, std::placeholders::_1);  // 绑定第一个参数为 5
     add5(3);  // 5 + 3 = 8
     ```


### **五、其他重要特性**
#### 1. **`noexcept` 说明符**
   - 声明函数不抛出异常，帮助编译器优化（如移动构造函数标记 `noexcept` 可提升性能）：
     ```cpp
     void func() noexcept {  // 不抛出异常
         // ...
     }
     ```


#### 2. ** constexpr 函数与常量表达式**
   - 允许函数在编译期执行，返回 constexpr 结果：
     ```cpp
     constexpr int factorial(int n) {
         return n <= 1 ? 1 : n * factorial(n - 1);
     }
     constexpr int val = factorial(5);  // 编译期计算为 120
     ```


#### 3. **`using` 声明与类型别名**
   - 替代 `typedef`，支持模板别名：
     ```cpp
     using IntVec = std::vector<int>;  // 等价于 typedef std::vector<int> IntVec;
     // 模板别名（typedef 不支持）
     template <typename T>
     using Ptr = T*;
     Ptr<int> p;  // int*
     ```


#### 4. **线程支持库（`<thread>`）**
   - 引入标准线程库，支持多线程编程：
     ```cpp
     #include <thread>
     void func() { std::cout << "Thread function"; }
     int main() {
         std::thread t(func);  // 创建线程
         t.join();  // 等待线程结束
         return 0;
     }
     ```
   - 配套组件：`std::mutex`（互斥锁）、`std::condition_variable`（条件变量）、`std::future`（异步结果）等。


### **总结**
C++11 的核心改进围绕 **简化代码**（如 `auto`、范围 for）、**提升性能**（移动语义、右值引用）、**增强安全性**（智能指针）、**泛型编程扩展**（变长参数模板、完美转发）展开，奠定了现代 C++ 的基础。后续 C++14/17/20 在此之上进一步扩展，但 **C++11 是必须掌握的里程碑版本**。学习时建议结合实际代码（如智能指针管理内存、lambda 表达式简化算法调用）加深理解。
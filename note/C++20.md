C++20 是 C++ 语言的一次革命性更新，引入了 **模块系统**、**协程**、**概念** 等重大特性，大幅提升了代码组织能力、抽象表达力和运行时效率。以下是 **C++20 核心知识点汇总**，按模块分类：


### **一、语言核心变革**
#### **1. 概念（Concepts）—— 类型约束的革命**
- **功能**：显式约束模板参数的类型要求，替代 SFINAE 黑魔法，使错误信息更友好，代码可读性更强。
- **语法**：
  - 定义概念：`template <typename T> concept 概念名 = 约束表达式;`
  - 使用概念：`template <概念名 T> void func(T t);` 或 `void func(概念名 auto t);`

  ```cpp
  #include <concepts>

  // 定义概念：整数类型
  template <typename T>
  concept Integral = std::is_integral_v<T>;

  // 定义概念：可相加类型（支持 + 运算符）
  template <typename T>
  concept Addable = requires(T a, T b) {
      { a + b } -> std::convertible_to<T>;  // 检查 a + b 是否合法且可转换为 T
  };

  // 使用概念约束模板
  template <Integral T>  // 仅接受整数类型
  T square(T x) { return x * x; }

  template <Addable T>  // 仅接受可相加类型
  T sum(T a, T b) { return a + b; }

  int main() {
      square(3);    // 正确（int 是 Integral）
      square(3.14); // 错误：double 不满足 Integral 约束
      sum(1, 2);    // 正确（int 可相加）
      sum("a", "b");// 错误：const char* 不满足 Addable 约束
  }
  ```
  **标准库概念**：`<concepts>` 头文件提供 `std::integral`、`std::floating_point`、`std::ranges::range` 等预定义概念。


#### **2. 模块（Modules）—— 替代头文件的现代方案**
- **问题**：传统头文件（`#include`）存在 **重复编译**、**命名污染**、**依赖复杂** 等问题。
- **模块优势**：
  - 编译隔离：模块内容仅编译一次，大幅提升编译速度。
  - 显式导出：仅导出需要公开的接口，避免命名冲突。
  - 依赖清晰：通过 `import` 声明依赖，替代文本包含。

  ```cpp
  // 模块定义文件：math.cppm（扩展名 .cppm 或 .ixx）
  export module math;  // 声明模块 math
  export namespace math {
      int add(int a, int b) { return a + b; }  // 导出 add 函数
      int multiply(int a, int b) { return a * b; }  // 导出 multiply 函数
  }

  // 使用模块：main.cpp
  import math;  // 导入 math 模块
  int main() {
      math::add(1, 2);      // 调用模块中的函数
      math::multiply(3, 4); // 4*3=12
      return 0;
  }
  ```
  **编译方式**：需编译器支持（GCC 11+、Clang 12+、MSVC 2019+），编译时需指定模块接口文件。


#### **3. 协程（Coroutines）—— 轻量级异步编程**
- **功能**：允许函数 **暂停执行** 并在后续恢复，实现高效的异步/并发代码（如事件循环、状态机），无需手动管理线程。
- **核心关键字**：
  - `co_return`：从协程返回值。
  - `co_await`：暂停协程，等待异步操作完成。
  - `co_yield`：返回中间结果（生成器场景）。

  ```cpp
  #include <coroutine>
  #include <future>

  // 简化的异步任务协程（返回 std::future<int>）
  std::future<int> async_task() {
      co_return 42;  // 协程暂停，返回 42 给 future
  }

  // 生成器协程（返回 0,1,2,...）
  generator<int> counter() {
      for (int i = 0;; ++i) {
          co_yield i;  // 返回 i 并暂停，下次调用恢复循环
      }
  }

  int main() {
      auto fut = async_task();
      std::cout << fut.get();  // 等待协程完成，输出 42

      auto gen = counter();
      std::cout << gen.next();  // 0
      std::cout << gen.next();  // 1
      return 0;
  }
  ```
  **注意**：C++20 仅定义协程框架，需手动实现协程 promise_type（或使用第三方库如 `cppcoro`）。


### **二、标准库重大更新**
#### **1. Ranges 库 —— 函数式编程范式**
- **功能**：重新设计的迭代器和算法库，支持 **链式调用**、**惰性计算**，代码更简洁易读。
- **核心组件**：
  - **范围（Ranges）**：封装迭代器对（`begin`/`end`），支持 `|` 运算符串联操作。
  - **视图（Views）**：惰性计算的范围适配器（如过滤、转换、切片），无额外内存开销。

  ```cpp
  #include <ranges>
  #include <vector>
  #include <iostream>

  int main() {
      std::vector<int> v{1, 2, 3, 4, 5, 6};
    
      // Ranges 链式操作：过滤偶数 → 平方 → 打印
      auto result = v | std::views::filter([](int x) { return x % 2 == 0; })
                      | std::views::transform([](int x) { return x * x; });
    
      for (int x : result) {
          std::cout << x << " ";  // 输出：4 16 36
      }
      return 0;
  }
  ```
  **优势**：避免临时变量，代码可读性接近自然语言（“取偶数，然后平方”）。


#### **2. 三路比较运算符（Three-Way Comparison）**
- **功能**：引入 `<=>`（太空船运算符），自动生成所有比较运算符（`==`、`!=`、`<`、`<=`、`>`、`>=`），简化代码。
- **语法**：`auto operator<=>(const T&) const = default;`（默认生成）或自定义。

  ```cpp
  struct Point {
      int x, y;
      // 默认生成三路比较运算符（比较 x，再比较 y）
      auto operator<=>(const Point&) const = default;
  };

  int main() {
      Point a{1, 2}, b{1, 3};
      a < b;   // true（a.y=2 < b.y=3）
      a == b;  // false
      a > b;   // false
      return 0;
  }
  ```
  **规则**：`<=>` 返回 `std::strong_ordering`（全序，如整数）、`std::weak_ordering`（弱序，如指针）或 `std::partial_ordering`（偏序，如浮点数 NaN）。


#### **3. `std::format` —— 类型安全的字符串格式化**
- **功能**：替代 `printf` 和 `std::cout` 拼接，支持 **类型安全**、**位置参数**、**格式说明符**，语法类似 Python 的 `str.format`。

  ```cpp
  #include <format>
  #include <string>

  int main() {
      std::string s = std::format("Hello, {}! Age: {}", "Alice", 30);  // "Hello, Alice! Age: 30"
      std::string num = std::format("Hex: {:x}, Oct: {:o}", 255, 255);  // "Hex: ff, Oct: 377"
      return 0;
  }
  ```
  **优势**：编译期检查类型，支持自定义格式，性能优于 `std::stringstream`。


#### **4. 日历与时间库（Calendar & Time Zones）**
- **功能**：标准化日期（年/月/日）、时间（时/分/秒）和时区操作，替代第三方库（如 Boost.DateTime）。

  ```cpp
  #include <chrono>
  #include <format>

  int main() {
      using namespace std::chrono;
    
      // 当前时间（系统时钟）
      auto now = system_clock::now();
      // 转换为本地时间（需 C++20 支持时区）
      auto local_time = zoned_time{current_zone(), now};
      std::cout << std::format("Current time: {}", local_time);  // 如：2024-05-20 15:30:45

      // 日期计算
      year_month_day ymd{2024y/May/20d};  // 2024年5月20日
      auto next_day = ymd + days{1};      // 2024-05-21
      return 0;
  }
  ```


### **三、其他重要特性**
#### **1. 约束的 auto（Constrained auto）**
- **功能**：用概念约束 `auto` 变量类型，编译期确保变量满足特定条件。

  ```cpp
  #include <concepts>

  std::integral auto x = 10;  // x 必须是整数类型（int, long, etc.）
  // std::integral auto y = 3.14;  // 错误：double 不满足 integral 约束

  // 函数参数中使用
  void func(std::floating_point auto x) {  // x 必须是浮点类型
      // ...
  }
  ```


#### **2. `consteval` 函数（编译期立即执行）**
- **功能**：标记函数必须在 **编译期执行**，返回编译期常量（比 `constexpr` 更严格，`constexpr` 可在运行期执行）。

  ```cpp
  consteval int square(int x) {  // 必须编译期执行
      return x * x;
  }

  int main() {
      constexpr int val = square(3);  // 编译期计算为 9
      // int n = 3; square(n);  // 错误：n 是运行期变量，无法编译期执行
      return 0;
  }
  ```


#### **3. 聚合体初始化扩展**
- **功能**：允许聚合体（如结构体、数组）使用括号初始化（`()`），并支持基类初始化。

  ```cpp
  struct A { int x; };
  struct B : A { int y; };

  int main() {
      A a(10);  // C++20 允许（之前仅支持 {}）
      B b{ {1}, 2 };  // 初始化基类 A 的 x=1，成员 y=2
      return 0;
  }
  ```


#### **4. `std::jthread` —— 可中断的线程**
- **功能**：`std::thread` 的改进版，支持 **自动 join**（析构时若未 join/detach 则自动 join）和 **中断机制**（通过 `stop_token`）。

  ```cpp
  #include <thread>
  #include <chrono>

  int main() {
      std::jthread t([](std::stop_token st) {  // 接收 stop_token
          while (!st.stop_requested()) {  // 检查是否请求中断
              std::this_thread::sleep_for(100ms);
          }
          std::cout << "Thread stopped\n";
      });
      // jthread 析构时自动 join，无需手动调用 t.join()
      return 0;
  }
  ```


### **C++20 核心特性全景图**
```
C++20
├─ 语言核心
│  ├─ 概念（Concepts）：模板类型约束，替代 SFINAE
│  ├─ 模块（Modules）：import/export 替代 #include，提升编译效率
│  ├─ 协程（Coroutines）：co_return/co_await/co_yield，轻量级异步
│  └─ 三路比较运算符（<=>）：自动生成比较运算符
├─ 标准库增强
│  ├─ Ranges 库：链式惰性算法（views::filter/transform）
│  ├─ std::format：类型安全的字符串格式化
│  ├─ 日历与时间库：year_month_day、时区支持
│  └─ std::jthread：可中断线程，自动 join
└─ 其他特性
   ├─ consteval：编译期立即执行函数
   ├─ 约束的 auto（std::integral auto x）
   └─ 聚合体初始化扩展（支持括号和基类初始化）
```


### **学习建议**
C++20 是 C++ 自 C++11 以来最具颠覆性的版本，学习优先级：
1. **概念（Concepts）**：重构模板代码，提升可读性和可维护性。
2. **Ranges 库**：简化算法调用，习惯函数式编程思维。
3. **`std::format`**：替代传统字符串拼接，必备工具。
4. **模块（Modules）**：大型项目中逐步迁移，解决头文件依赖问题。
5. **协程**：理解异步编程模型，结合第三方库（如 `cppcoro`）实践。

C++20 特性需较新编译器支持（GCC 10+、Clang 13+、MSVC 2019+），建议使用 GCC 11+ 或 Clang 14+ 体验完整功能。
好的，我们已经讨论了并发服务器的实现方式（多进程、多线程），以及如何通过I/O多路复用高效处理大量连接。然而，当多个执行流（进程或线程）同时访问和修改共享资源时，就会出现一个非常关键的问题：**数据一致性与同步**。

### 第十二次讲解：并发编程中的同步与互斥 (针对共享内存等)

### 1. 为什么需要同步与互斥？

在并发编程中，多个线程或进程可能同时访问相同的内存区域、文件、数据库连接、套接字等共享资源。如果没有适当的协调机制，就可能发生以下问题：

*   **竞态条件 (Race Condition):** 多个执行流尝试同时修改共享数据，最终结果取决于它们执行的精确时序，导致结果不可预测且不正确。
    *   **示例:** 一个全局计数器`counter`，两个线程同时执行`counter++`。`counter++`实际上是“读取-修改-写入”三步操作。如果两个线程同时读取到`counter`的旧值，然后都基于旧值进行修改并写回，最终`counter`可能只增加了1次，而不是预期的2次。
*   **数据不一致 (Data Inconsistency):** 共享数据在某个时刻处于不正确的状态，或者不同的执行流看到的数据视图不一致。

为了解决这些问题，我们需要引入**同步 (Synchronization)** 和 **互斥 (Mutual Exclusion)** 机制。

*   **互斥:** 确保在任何给定时刻，只有一个执行流能够访问特定的共享资源（临界区）。
*   **同步:** 协调多个执行流的执行顺序，确保它们在特定点上进行协作。

### 2. 临界区 (Critical Section)

**临界区**是指访问共享资源的代码段。在任何时刻，只允许一个执行流进入临界区执行。通过保护临界区，我们可以避免竞态条件。

### 3. 同步与互斥的基本原语

Linux提供了多种同步与互斥原语，主要通过POSIX标准（`pthread`库和`semaphore.h`）实现。

#### 3.1 互斥锁 (Mutex - Mutual Exclusion Lock)

互斥锁是最基本的同步原语，用于保护临界区，实现排他性访问。

*   **类型:** `pthread_mutex_t`
*   **基本操作:**
    *   **初始化:** `pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)`
        *   `attr`通常为`NULL`，表示使用默认属性（快速锁）。
    *   **加锁:** `pthread_mutex_lock(pthread_mutex_t *mutex)`
        *   如果锁已被占用，调用线程将阻塞，直到锁被释放。
    *   **尝试加锁:** `pthread_mutex_trylock(pthread_mutex_t *mutex)`
        *   非阻塞加锁。如果锁已被占用，立即返回错误（`EBUSY`），而不是阻塞。
    *   **解锁:** `pthread_mutex_unlock(pthread_mutex_t *mutex)`
    *   **销毁:** `pthread_mutex_destroy(pthread_mutex_t *mutex)`
        *   销毁前确保没有线程持有该锁。

**使用场景:** 保护共享变量、共享数据结构、文件访问等。

**示例：使用互斥锁保护全局计数器**

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h> // For pthreads
#include <unistd.h>  // For sleep

long long global_counter = 0;
pthread_mutex_t counter_mutex; // 互斥锁

void *increment_counter(void *arg) {
    int i;
    for (i = 0; i < 100000; i++) {
        pthread_mutex_lock(&counter_mutex); // 进入临界区：加锁
        global_counter++;                   // 访问共享资源
        pthread_mutex_unlock(&counter_mutex); // 退出临界区：解锁
    }
    return NULL;
}

int main() {
    pthread_t tid1, tid2;

    // 初始化互斥锁
    if (pthread_mutex_init(&counter_mutex, NULL) != 0) {
        perror("mutex init failed");
        return 1;
    }

    // 创建两个线程，都执行 increment_counter
    pthread_create(&tid1, NULL, increment_counter, NULL);
    pthread_create(&tid2, NULL, increment_counter, NULL);

    // 等待线程结束
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    // 销毁互斥锁
    pthread_mutex_destroy(&counter_mutex);

    printf("Final global_counter: %lld\n", global_counter); // 预期结果：200000
    return 0;
}
```
**编译:** `gcc -o mutex_example mutex_example.c -lpthread`
**运行:** `./mutex_example`

#### 3.2 信号量 (Semaphore)

信号量是一种更通用的同步原语，可以用于实现互斥（二元信号量）或资源计数（计数信号量）。它维护一个内部计数器。

*   **类型:** `sem_t`
*   **基本操作:**
    *   **初始化:** `sem_init(sem_t *sem, int pshared, unsigned int value)`
        *   `pshared`: 0表示线程间共享（进程内），非0表示进程间共享（需要共享内存）。
        *   `value`: 信号量的初始值。
    *   **P操作 (等待/递减):** `sem_wait(sem_t *sem)`
        *   将信号量值减1。如果值为0，调用线程阻塞，直到信号量值大于0。
    *   **V操作 (发布/递增):** `sem_post(sem_t *sem)`
        *   将信号量值加1。如果等待队列中有线程，唤醒其中一个。
    *   **尝试P操作:** `sem_trywait(sem_t *sem)` (非阻塞)
    *   **销毁:** `sem_destroy(sem_t *sem)`

**使用场景:**
*   **互斥:** 当`value`为1时，作为二元信号量，功能类似互斥锁。
*   **资源计数:** 限制对有限资源的访问（例如，限制同时访问数据库连接的线程数）。
*   **生产者-消费者问题:** 协调生产者和消费者线程对共享缓冲区的访问。

**示例：信号量实现互斥 (类似互斥锁)**

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h> // For semaphores
#include <unistd.h>

long long global_counter_sem = 0;
sem_t counter_sem; // 信号量

void *increment_counter_sem(void *arg) {
    int i;
    for (i = 0; i < 100000; i++) {
        sem_wait(&counter_sem);     // P操作：等待信号量，减1
        global_counter_sem++;       // 访问共享资源
        sem_post(&counter_sem);     // V操作：释放信号量，加1
    }
    return NULL;
}

int main() {
    pthread_t tid1, tid2;

    // 初始化信号量为1 (二元信号量，实现互斥)
    if (sem_init(&counter_sem, 0, 1) != 0) {
        perror("semaphore init failed");
        return 1;
    }

    pthread_create(&tid1, NULL, increment_counter_sem, NULL);
    pthread_create(&tid2, NULL, increment_counter_sem, NULL);

    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    sem_destroy(&counter_sem); // 销毁信号量

    printf("Final global_counter_sem: %lld\n", global_counter_sem); // 预期结果：200000
    return 0;
}
```
**编译:** `gcc -o semaphore_example semaphore_example.c -lpthread -lrt` (注意`-lrt`对于命名信号量或共享信号量有时是必需的)

#### 3.3 条件变量 (Condition Variable)

条件变量本身不提供互斥功能，它必须与互斥锁一起使用。条件变量用于线程等待某个特定条件发生。

*   **类型:** `pthread_cond_t`
*   **基本操作:**
    *   **初始化:** `pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr)`
    *   **等待条件:** `pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)`
        *   **原子操作:** 自动释放互斥锁并阻塞等待条件。当被唤醒时，重新获取互斥锁。
        *   **惊群效应 (Thundering Herd):** 多个等待线程被唤醒后，只有第一个能获得锁并检查条件，其他线程可能再次进入等待。
    *   **带超时等待:** `pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime)`
    *   **发送信号 (唤醒一个):** `pthread_cond_signal(pthread_cond_t *cond)`
        *   唤醒一个等待在该条件变量上的线程。
    *   **广播信号 (唤醒所有):** `pthread_cond_broadcast(pthread_cond_t *cond)`
        *   唤醒所有等待在该条件变量上的线程。
    *   **销毁:** `pthread_cond_destroy(pthread_cond_t *cond)`

**使用场景:** 生产者-消费者模型、线程池、主线程等待子线程完成某个任务等。

**示例：生产者-消费者模型 (生产者等待缓冲区不满，消费者等待缓冲区不空)**

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <stdbool.h> // For bool type

#define BUFFER_SIZE 5

int buffer[BUFFER_SIZE];
int count = 0; // 缓冲区当前项目数量
int in = 0;    // 生产者放入位置
int out = 0;   // 消费者取出位置

pthread_mutex_t buffer_mutex;       // 保护缓冲区访问
pthread_cond_t cond_producer;       // 生产者等待缓冲区不满
pthread_cond_t cond_consumer;       // 消费者等待缓冲区不空

void *producer(void *arg) {
    int item;
    for (int i = 0; i < 20; i++) {
        item = i + 1; // 生产一个项目

        pthread_mutex_lock(&buffer_mutex); // 保护缓冲区

        while (count == BUFFER_SIZE) { // 如果缓冲区已满，生产者等待
            printf("Producer: Buffer full, waiting...\n");
            pthread_cond_wait(&cond_producer, &buffer_mutex);
        }

        buffer[in] = item;
        in = (in + 1) % BUFFER_SIZE;
        count++;
        printf("Producer: Produced %d. Count: %d\n", item, count);

        pthread_cond_signal(&cond_consumer); // 唤醒消费者（缓冲区不空了）
        pthread_mutex_unlock(&buffer_mutex); // 解锁

        usleep(100000); // 模拟生产时间
    }
    return NULL;
}

void *consumer(void *arg) {
    int item;
    for (int i = 0; i < 20; i++) {
        pthread_mutex_lock(&buffer_mutex); // 保护缓冲区

        while (count == 0) { // 如果缓冲区为空，消费者等待
            printf("Consumer: Buffer empty, waiting...\n");
            pthread_cond_wait(&cond_consumer, &buffer_mutex);
        }

        item = buffer[out];
        out = (out + 1) % BUFFER_SIZE;
        count--;
        printf("Consumer: Consumed %d. Count: %d\n", item, count);

        pthread_cond_signal(&cond_producer); // 唤醒生产者（缓冲区不满了）
        pthread_mutex_unlock(&buffer_mutex); // 解锁

        usleep(150000); // 模拟消费时间
    }
    return NULL;
}

int main() {
    pthread_t prod_tid, cons_tid;

    pthread_mutex_init(&buffer_mutex, NULL);
    pthread_cond_init(&cond_producer, NULL);
    pthread_cond_init(&cond_consumer, NULL);

    pthread_create(&prod_tid, NULL, producer, NULL);
    pthread_create(&cons_tid, NULL, consumer, NULL);

    pthread_join(prod_tid, NULL);
    pthread_join(cons_tid, NULL);

    pthread_mutex_destroy(&buffer_mutex);
    pthread_cond_destroy(&cond_producer);
    pthread_cond_destroy(&cond_consumer);

    printf("Main: Done.\n");
    return 0;
}
```
**编译:** `gcc -o cond_var_example cond_var_example.c -lpthread`

#### 3.4 读写锁 (Reader-Writer Lock)

读写锁允许多个读线程同时访问共享资源，但在写线程访问时，所有读线程和写线程都必须等待。

*   **类型:** `pthread_rwlock_t`
*   **基本操作:**
    *   **初始化:** `pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr)`
    *   **加读锁:** `pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)`
    *   **加写锁:** `pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)`
    *   **解锁:** `pthread_rwlock_unlock(pthread_rwlock_t *rwlock)` (读锁和写锁都用这个解锁)
    *   **销毁:** `pthread_rwlock_destroy(pthread_rwlock_t *rwlock)`

**使用场景:** 共享数据读多写少的场景，可以提高并发性。

### 4. 进程间同步 (IPC Synchronization)

上述讨论的互斥锁、信号量和条件变量，默认是用于**线程间同步**的（即在同一个进程内的不同线程）。

如果需要在**不同进程之间**进行同步，共享的同步原语需要放置在**共享内存**中，并且在初始化时需要设置`pshared`参数。

*   **`sem_init()`:** 第二个参数`pshared`设为非0。
*   **`pthread_mutex_init()` / `pthread_cond_init()`:** 它们的`attr`参数可以设置`PTHREAD_PROCESS_SHARED`属性。

**进程间共享内存的创建和映射:**
*   **`shm_open()` / `mmap()`:** POSIX共享内存。
*   **`shmget()` / `shmat()`:** System V共享内存（较老）。

### 5. 并发编程的常见问题

*   **死锁 (Deadlock):** 两个或多个执行流无限期地互相等待对方释放资源而无法继续执行。
    *   **原因:** 循环等待、请求并持有、不可剥夺、互斥条件同时满足。
    *   **避免:** 资源有序分配、超时机制、银行家算法等。
*   **活锁 (Livelock):** 两个或多个执行流都在不断改变状态，但都没有取得进展，反复尝试和失败。
    *   **示例:** 两个线程都检测到冲突并回退，然后再次冲突，无限循环。
*   **饥饿 (Starvation):** 某个执行流因为调度策略或资源分配不公平，长时间无法获得所需的资源而无法执行。
    *   **示例:** 优先级低的线程可能总被优先级高的线程抢占CPU，或者在读写锁中，如果写锁请求持续不断，读锁可能永远无法获取。

### 6. 在网络编程中的应用

在复杂的Linux网络服务器中，同步与互斥原语无处不在：

*   **线程池/进程池:** 管理工作线程/进程的生命周期，调度任务。
*   **连接管理:** 维护活动的客户端连接列表（例如，一个`map<int, ConnectionInfo>`），当新连接到来或旧连接关闭时，需要加锁修改。
*   **共享缓存:** 多个工作线程访问同一个内存缓存（例如，DNS解析缓存、Web页面缓存），需要互斥锁或读写锁。
*   **日志系统:** 多个线程同时写入同一个日志文件，需要互斥锁保护文件写入。
*   **统计信息:** 多个线程更新服务器的全局统计数据（如请求计数、流量），需要互斥锁保护。
*   **任务队列:** 生产者（如`epoll`事件循环）将任务放入队列，消费者（工作线程）从队列取出任务，典型的生产者-消费者模型，需要互斥锁和条件变量。

理解并熟练运用这些同步与互斥机制是编写高性能、健壮的并发网络应用程序的基石。

至此，我们对并发编程中的同步与互斥有了全面的认识。如果你有其他感兴趣的领域，或者想更深入地探讨某个特定主题，请告诉我！例如：
*   **Linux网络配置与工具**
*   **异步I/O (AIO) 的更深层机制**
*   **更复杂的IPC机制（管道、消息队列、System V IPC）**
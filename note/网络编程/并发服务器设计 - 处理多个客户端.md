好的，我们继续深入。

### 第四次讲解：并发服务器设计 - 处理多个客户端

在上次的讲解中，我们实现了一个简单的TCP服务器，它一次只能处理一个客户端连接。一旦客户端连接并通信完毕，服务器就关闭了。这显然不符合实际应用的需求，因为真实的服务器需要同时为成千上万个客户端提供服务。

因此，理解**并发服务器**的设计是Linux网络编程中非常重要的一步。

### 1. 单进程/单线程服务器的局限性

我们之前的服务器是“阻塞的”：
*   `accept()` 函数会一直阻塞，直到有新的客户端连接到来。
*   `read()`/`write()` 函数在读写数据时也会阻塞，直到数据发送/接收完成。

这意味着：当一个客户端连接上来后，服务器会完全专注于与这个客户端的通信。在它完成与这个客户端的通信之前，即使有其他客户端发起连接请求，服务器也无法响应，它们只能在监听队列中等待，或者直接被拒绝（如果队列满了）。这导致了糟糕的用户体验和低效的资源利用。

为了解决这个问题，我们需要让服务器能够**并发**地处理多个客户端连接。

### 2. 并发服务器的实现方式

在Linux网络编程中，实现并发服务器主要有以下几种常见方式：

1.  **多进程 (Multi-process):** 为每个新的客户端连接派生（`fork()`) 一个独立的子进程来处理。
2.  **多线程 (Multi-threaded):** 为每个新的客户端连接创建一个独立的线程来处理。
3.  **I/O 多路复用 (I/O Multiplexing):** 使用 `select()`, `poll()`, `epoll()` 等机制，在一个进程/线程中同时监控多个套接字的I/O事件。
4.  **异步I/O (Asynchronous I/O - AIO):** 很少直接在Socket编程中使用，更多是在文件I/O等场景。

我们首先来看最常用的两种方式：多进程和多线程。

---

### 3. 多进程并发服务器 (Fork-based Server)

这种方式的原理是：当主进程（监听进程）`accept()`到一个新的客户端连接后，它会立即`fork()`一个子进程。这个子进程负责与新连接的客户端进行通信，而主进程则回到`listen()`/`accept()`循环中，继续等待并接受新的连接。

#### 核心概念：`fork()` 系统调用

*   **功能:** `fork()` 系统调用用于创建一个新的进程，这个新的进程是当前进程（父进程）的精确副本。子进程获得父进程的数据段、堆、栈的副本，以及文件描述符的副本。
*   **函数原型:** `pid_t fork(void);`
*   **返回值:**
    *   在父进程中，`fork()`返回新创建的子进程的PID（进程ID）。
    *   在子进程中，`fork()`返回0。
    *   如果创建失败，返回 -1。

#### 多进程服务器的工作流程：

```mermaid
graph TD
    A[服务器主进程启动] --> B{socket(), bind(), listen()};
    B --> C{循环: accept()};
    C -- 成功接受新连接 --> D{fork()};
    D -- fork()返回子进程PID(>0) --> C;
    D -- fork()返回0(子进程) --> E[子进程];
    E --> F[关闭监听套接字(server_fd)];
    F --> G[处理客户端通信(read/write using new_socket)];
    G --> H[关闭已连接套接字(new_socket)];
    H --> I[子进程退出];
```

#### 多进程服务器的伪代码结构：

```c
// ... 省略头文件和常量定义 ...

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    // ... 其他变量 ...

    // 1. 创建、绑定、监听套接字 (与之前相同)
    server_fd = socket(...);
    bind(server_fd, ...);
    listen(server_fd, ...);

    printf("Server: Listening on port %d...\n", PORT);

    // 主循环：不断接受新的连接
    while (1) {
        // 2. 接受客户端连接
        new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);
        if (new_socket < 0) {
            perror("accept failed");
            // 可以选择继续循环或者退出
            continue;
        }
        printf("Server: Accepted new connection from %s:%d\n",
               inet_ntoa(address.sin_addr), ntohs(address.sin_port));

        // 3. 派生子进程
        pid_t pid = fork();

        if (pid < 0) {
            perror("fork failed");
            close(new_socket); // 关闭这个客户端连接
            continue; // 继续等待下一个连接
        } else if (pid == 0) { // 子进程
            // 4. 子进程处理逻辑
            close(server_fd); // 子进程不需要监听套接字，关闭它
            printf("Child process %d: Handling client...\n", getpid());

            // 这里是子进程与客户端通信的代码
            // 例如：
            char buffer[MAX_BUFFER_SIZE];
            ssize_t valread = read(new_socket, buffer, MAX_BUFFER_SIZE);
            if (valread > 0) {
                printf("Child process %d: Received: %s\n", getpid(), buffer);
                send(new_socket, "Hello from child server!", strlen("Hello from child server!"), 0);
            } else if (valread == 0) {
                printf("Child process %d: Client disconnected.\n", getpid());
            } else {
                perror("read failed in child");
            }
            
            close(new_socket); // 子进程处理完后关闭已连接套接字
            printf("Child process %d: Client handled, exiting.\n", getpid());
            exit(0); // 子进程退出
        } else { // 父进程
            // 5. 父进程逻辑
            close(new_socket); // 父进程不需要已连接套接字，关闭它
            // 父进程继续循环，等待下一个客户端连接
            // 注意：父进程需要处理子进程的僵尸状态（见下）
        }
    }

    // 这部分代码通常不会执行，除非循环被中断
    close(server_fd);
    return 0;
}
```

#### 多进程服务器的优点：

*   **进程隔离:** 每个客户端都在独立的进程中运行，一个子进程的崩溃不会影响其他进程或主进程，这增加了服务器的稳定性。
*   **简单性:** 对于并发处理，`fork()`的模型相对直观和简单，避免了线程间的同步问题。

#### 多进程服务器的缺点：

*   **资源开销大:** 进程创建和销毁的开销相对较大，每个进程都有独立的地址空间，内存消耗较高。
*   **通信复杂:** 进程间通信 (IPC) 相对复杂，需要使用管道、消息队列、共享内存等机制。
*   **僵尸进程问题:** 如果父进程不及时处理（`wait()`或`waitpid()`）已退出的子进程，子进程会变成“僵尸进程”，占用系统资源。

#### 处理僵尸进程：

为了避免僵尸进程，父进程需要通过`wait()`或`waitpid()`系统调用回收子进程资源。一个常见的做法是：

1.  **信号处理:** 注册`SIGCHLD`信号处理器。当子进程退出时，内核会向父进程发送`SIGCHLD`信号。
2.  **在信号处理器中调用 `waitpid()`:** 在信号处理器中循环调用`waitpid(-1, NULL, WNOHANG)`。
    *   `-1`表示等待任何子进程。
    *   `NULL`表示不关心子进程的退出状态。
    *   `WNOHANG`表示非阻塞，如果没有子进程退出，`waitpid`立即返回0，避免信号处理器阻塞。

示例（添加到`main`函数开头，在`while(1)`循环之前）：

```c
#include <sys/wait.h> // for waitpid
#include <signal.h>   // for signal

// 信号处理函数
void sigchld_handler(int s) {
    // waitpid() might overwrite errno, so we save and restore it
    int saved_errno = errno;
    while(waitpid(-1, NULL, WNOHANG) > 0);
    errno = saved_errno;
}

// ... main 函数中 ...
int main() {
    // ...
    struct sigaction sa;
    sa.sa_handler = sigchld_handler; // 注册信号处理器
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART | SA_NOCLDSTOP; // SA_RESTART: 重启被中断的系统调用; SA_NOCLDSTOP: 子进程停止时不发送信号
    if (sigaction(SIGCHLD, &sa, NULL) == -1) {
        perror("sigaction failed");
        exit(EXIT_FAILURE);
    }
    // ...
}
```

---

### 4. 多线程并发服务器 (Thread-based Server)

多线程方式是另一种常用的并发模型。在一个进程内创建多个线程来处理不同的客户端连接。所有线程共享进程的地址空间，这使得数据共享变得更容易，但同时也引入了同步（互斥、死锁）的复杂性。

#### 核心概念：`pthread_create()`

*   **功能:** 创建一个新的线程。
*   **函数原型:**
    ```c
    #include <pthread.h>
    int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                       void *(*start_routine) (void *), void *arg);
    ```
*   **参数:**
    *   `thread`: 指向`pthread_t`类型变量的指针，用于存储新线程的ID。
    *   `attr`: 线程属性，通常设为`NULL`使用默认属性。
    *   `start_routine`: 线程的入口函数（线程执行的代码）。
    *   `arg`: 传递给线程入口函数的参数。

#### 多线程服务器的工作流程：

```mermaid
graph TD
    A[服务器主线程启动] --> B{socket(), bind(), listen()};
    B --> C{循环: accept()};
    C -- 成功接受新连接 --> D{pthread_create()};
    D --> E[新线程];
    E --> F[处理客户端通信(read/write using new_socket)];
    F --> G[新线程退出];
    D --> C;
```

#### 多线程服务器的伪代码结构：

```c
// ... 省略头文件和常量定义 ...
#include <pthread.h> // For pthreads

// 线程处理函数，每个新线程都会执行这个函数
void *handle_client(void *socket_desc) {
    int new_socket = *(int*)socket_desc; // 获取已连接套接字
    free(socket_desc); // 释放传递进来的内存

    char buffer[MAX_BUFFER_SIZE];
    // ... 线程与客户端通信逻辑 ...
    ssize_t valread = read(new_socket, buffer, MAX_BUFFER_SIZE);
    if (valread > 0) {
        printf("Thread %lu: Received: %s\n", pthread_self(), buffer);
        send(new_socket, "Hello from threaded server!", strlen("Hello from threaded server!"), 0);
    } else if (valread == 0) {
        printf("Thread %lu: Client disconnected.\n", pthread_self());
    } else {
        perror("read failed in thread");
    }

    close(new_socket); // 关闭已连接套接字
    printf("Thread %lu: Client handled, exiting.\n", pthread_self());
    pthread_exit(NULL); // 线程退出
}

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    // ... 其他变量 ...

    // 1. 创建、绑定、监听套接字 (与之前相同)
    server_fd = socket(...);
    bind(server_fd, ...);
    listen(server_fd, ...);

    printf("Server: Listening on port %d...\n", PORT);

    // 主循环：不断接受新的连接
    while (1) {
        // 2. 接受客户端连接
        new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);
        if (new_socket < 0) {
            perror("accept failed");
            continue;
        }
        printf("Server: Accepted new connection from %s:%d\n",
               inet_ntoa(address.sin_addr), ntohs(address.sin_port));

        // 3. 为新连接创建线程
        pthread_t client_thread;
        // 注意：这里需要动态分配内存来传递new_socket，因为new_socket是局部变量
        // 否则当主线程的new_socket值改变时，子线程可能读取到错误的值
        int *new_sock_ptr = (int *)malloc(sizeof(int));
        if (new_sock_ptr == NULL) {
            perror("malloc failed");
            close(new_socket);
            continue;
        }
        *new_sock_ptr = new_socket;

        if (pthread_create(&client_thread, NULL, handle_client, (void*)new_sock_ptr) < 0) {
            perror("could not create thread");
            close(new_socket);
            free(new_sock_ptr);
            continue;
        }
        // 分离线程，使其资源在结束后自动回收，不需要join
        pthread_detach(client_thread); 
        // 父线程不需要管理新连接套接字，也不需要再关闭它，因为线程会处理
    }

    // ...
    close(server_fd);
    return 0;
}
```
**编译多线程代码时需要链接`pthread`库：**
`gcc server_threaded.c -o server_threaded -lpthread`

#### 多线程服务器的优点：

*   **资源开销小:** 线程共享进程的地址空间，创建和销毁开销比进程小，内存消耗更少。
*   **数据共享方便:** 线程间数据共享直接，通过全局变量或传递指针即可，但需要小心同步问题。
*   **上下文切换开销小:** 线程间的上下文切换比进程间快。

#### 多线程服务器的缺点：

*   **同步复杂:** 多个线程访问共享数据时需要复杂的同步机制（互斥锁、条件变量、读写锁等），容易引入死锁、竞态条件等问题。
*   **稳定性:** 一个线程的崩溃可能会导致整个进程崩溃。
*   **调试困难:** 多线程程序的调试比单线程或多进程复杂。

---

### 5. 多进程 vs. 多线程 总结

| 特性           | 多进程 (fork)                                  | 多线程 (pthread)                               |
| :------------- | :--------------------------------------------- | :--------------------------------------------- |
| **独立性/隔离** | 高 (独立的地址空间，一个进程崩溃不影响其他)    | 低 (共享地址空间，一个线程崩溃可能导致整个进程崩溃) |
| **资源开销**   | 大 (创建、内存)                                  | 小 (创建、内存)                                  |
| **数据共享**   | 困难 (需要IPC机制)                             | 容易 (共享内存，但需要同步)                       |
| **编程复杂性** | 相对简单 (避免数据同步问题)                    | 复杂 (需要处理线程同步，如互斥锁、死锁)          |
| **上下文切换** | 慢                                             | 快                                             |
| **适用场景**   | 要求高隔离性、每个连接处理逻辑相对独立的场景   | 要求高并发、需要频繁共享数据、低延迟的场景       |

在实际的Web服务器、数据库服务器等高并发应用中，通常会结合使用线程池或进程池来限制并发数量，避免资源耗尽。

下次我们将深入探讨更高级和更高效的并发模型：**I/O 多路复用 (I/O Multiplexing)**，尤其是 `epoll`，它是处理C10K问题的关键。
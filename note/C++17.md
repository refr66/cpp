C++17 是继 C++11 之后的又一个重大版本，引入了大量实用特性，进一步简化代码、提升性能，并增强标准库功能。以下是 **C++17 核心知识点汇总**，按类别整理：


### **一、语言核心特性**
#### **1. 结构化绑定（Structured Bindings）**
- **功能**：将结构体、数组、元组等复合类型的成员 **一次性绑定到多个变量**，简化取值操作。
- **语法**：`auto [var1, var2, ...] = 复合类型对象;`

  ```cpp
  #include <tuple>
  #include <map>

  // 1. 绑定元组
  std::tuple<int, std::string, double> t(1, "hello", 3.14);
  auto [id, str, val] = t;  // id=1, str="hello", val=3.14

  // 2. 绑定数组
  int arr[3] = {10, 20, 30};
  auto [a, b, c] = arr;  // a=10, b=20, c=30

  // 3. 绑定结构体/类（需public成员或getter）
  struct Point { int x, y; };
  Point p{1, 2};
  auto [x, y] = p;  // x=1, y=2

  // 4. 绑定map迭代器（最常用场景）
  std::map<std::string, int> mp{{"a", 1}, {"b", 2}};
  for (auto [key, value] : mp) {  // 遍历key和value
      std::cout << key << ":" << value << "\n";
  }
  ```


#### **2. if/switch 初始化语句（Init Statements）**
- **功能**：在 `if`/`switch` 条件判断前 **声明并初始化变量**，作用域限定在语句块内，避免污染外部作用域。

  ```cpp
  // if 初始化（例：安全检查智能指针）
  if (auto ptr = get_ptr(); ptr != nullptr) {  // 初始化ptr并判断
      ptr->do_something();
  }  // ptr作用域结束

  // switch 初始化（例：处理临时变量）
  switch (int val = compute_value(); val) {  // 初始化val并判断
      case 1: ...; break;
      case 2: ...; break;
  }
  ```


#### **3. 折叠表达式（Fold Expressions）**
- **功能**：简化 **变长参数模板** 的参数包展开，支持对参数包进行 **一元/二元运算**（如求和、打印、逻辑与）。
- **语法**：
  - 一元右折叠：`(args op ...)`
  - 一元左折叠：`(... op args)`
  - 二元右折叠：`(args op ... op init)`
  - 二元左折叠：`(init op ... op args)`

  ```cpp
  #include <iostream>

  // 1. 求和（二元左折叠，初始值0）
  template <typename... Args>
  auto sum(Args&&... args) {
      return (0 + ... + args);  // 等价于 0 + arg1 + arg2 + ... + argN
  }

  // 2. 打印所有参数（一元右折叠，使用逗号运算符）
  template <typename... Args>
  void print(Args&&... args) {
      (std::cout << ... << args) << "\n";  // 等价于 cout << arg1 << arg2 << ... << argN
  }

  // 3. 逻辑与（判断所有参数是否为真）
  template <typename... Args>
  bool all_true(Args&&... args) {
      return (... && args);  // 等价于 arg1 && arg2 && ... && argN
  }

  int main() {
      sum(1, 2, 3);  // 6
      print("a", 1, 3.14);  // a13.14
      all_true(1, true, 3 > 2);  // true
  }
  ```


#### **4. `constexpr if`**
- **功能**：编译期条件判断，根据条件选择不同代码分支（**分支不满足条件时不编译**，避免运行时开销）。
- **语法**：`if constexpr (编译期条件) { ... } else { ... }`

  ```cpp
  template <typename T>
  auto get_value(T t) {
      if constexpr (std::is_integral_v<T>) {
          return t * 2;  // 整数类型执行
      } else {
          return t;      // 非整数类型执行（如字符串、浮点数）
      }
  }

  int main() {
      get_value(10);      // 20（整数分支）
      get_value(3.14);    // 3.14（非整数分支）
      get_value("hello"); // "hello"（非整数分支）
  }
  ```


### **二、标准库增强**
#### **1. `std::string_view`**
- **功能**：轻量级字符串“视图”，**不管理内存**，仅存储字符串的指针和长度，避免不必要的字符串拷贝。
- **适用场景**：函数参数传递、临时字符串操作（如子串提取）。

  ```cpp
  #include <string_view>

  // 接受 string_view，避免拷贝（兼容 const char* 和 std::string）
  void print_str(std::string_view str) {
      std::cout << str << "\n";
  }

  int main() {
      std::string s = "hello";
      std::string_view sv = s;  // 指向 s 的内容，无拷贝
      std::string_view sub = sv.substr(0, 3);  // "hel"，无拷贝
      print_str("world");  // 直接接受字面量，无拷贝
      return 0;
  }
  ```


#### **2. 并行算法（Parallel Algorithms）**
- **功能**：STL 算法新增 **并行执行策略**，支持多线程加速（需编译器和标准库支持，如 GCC 9+、MSVC）。
- **策略参数**：
  - `std::execution::seq`：顺序执行（默认）
  - `std::execution::par`：并行执行（多线程）
  - `std::execution::par_unseq`：并行+向量化执行

  ```cpp
  #include <vector>
  #include <algorithm>
  #include <execution>  // 并行策略头文件

  int main() {
      std::vector<int> v(1000000);
      // 并行填充（比 std::fill 更快）
      std::fill(std::execution::par, v.begin(), v.end(), 42);
      // 并行排序（比 std::sort 更快）
      std::sort(std::execution::par, v.begin(), v.end());
      return 0;
  }
  ```


#### **3. `std::filesystem`（文件系统库）**
- **功能**：标准化文件系统操作（取代 POSIX `stat` 或 Windows API），支持路径操作、文件读写、目录遍历等。
- **核心类**：`std::filesystem::path`（路径）、`std::filesystem::directory_iterator`（目录迭代器）。

  ```cpp
  #include <filesystem>
  namespace fs = std::filesystem;  // 简化命名空间

  int main() {
      fs::path p = "/home/user/doc.txt";  // 路径对象
      if (fs::exists(p)) {  // 判断文件是否存在
          std::cout << "Size: " << fs::file_size(p) << " bytes\n";
      }
      // 遍历目录
      for (const auto& entry : fs::directory_iterator("/home/user")) {
          std::cout << entry.path() << "\n";  // 打印目录下所有文件/子目录
      }
      return 0;
  }
  ```


#### **4. `std::optional`**
- **功能**：表示“可能存在的值”，避免使用 `nullptr` 或特殊值（如 `-1`）表示“无值”，增强代码可读性和安全性。

  ```cpp
  #include <optional>

  // 返回 optional<int>，表示可能无结果
  std::optional<int> find_in_vector(const std::vector<int>& v, int target) {
      auto it = std::find(v.begin(), v.end(), target);
      if (it != v.end()) {
          return *it;  // 有值：返回 optional 包装的结果
      } else {
          return std::nullopt;  // 无值：返回 nullopt
      }
  }

  int main() {
      std::vector<int> v{1, 2, 3};
      auto res = find_in_vector(v, 2);
      if (res.has_value()) {  // 判断是否有值
          std::cout << "Found: " << res.value() << "\n";  // 获取值（2）
      }
      // 或使用 operator*（需先检查 has_value()）
      if (res) {
          std::cout << "Found: " << *res << "\n";
      }
      return 0;
  }
  ```


#### **5. `std::variant`**
- **功能**：类型安全的“联合体”（union），可存储多种类型中的一种，避免原始 union 的不安全访问。

  ```cpp
  #include <variant>
  #include <string>

  int main() {
      std::variant<int, std::string, double> var;  // 可存储 int/string/double
      var = 10;  // 存储 int
      var = "hello";  // 存储 string（覆盖之前的值）
    
      // 访问方式1：get_if（返回指针，失败返回nullptr）
      if (auto p = std::get_if<std::string>(&var)) {
          std::cout << "String: " << *p << "\n";  // "hello"
      }
    
      // 访问方式2：visit（访问者模式，对当前类型执行操作）
      std::visit([](auto&& arg) {
          using T = std::decay_t<decltype(arg)>;
          if constexpr (std::is_same_v<T, int>) {
              std::cout << "Int: " << arg << "\n";
          } else if constexpr (std::is_same_v<T, std::string>) {
              std::cout << "String: " << arg << "\n";
          }
      }, var);  // 输出 "String: hello"
      return 0;
  }
  ```


### **三、其他重要特性**
#### **1. `inline` 变量（Inline Variables）**
- **功能**：允许全局变量在头文件中定义（用 `inline` 标记），避免“多重定义”错误（类似 `inline` 函数）。

  ```cpp
  // config.h（头文件）
  inline const int MAX_SIZE = 1024;  // 内联变量，可在多个文件中包含
  inline std::string VERSION = "1.0.0";
  ```


#### **2. `[[nodiscard]]` 属性**
- **功能**：标记函数返回值 **必须被使用**，若调用者忽略返回值，编译器会警告（避免忘记处理返回值，如错误码）。

  ```cpp
  [[nodiscard]] bool save_data() {  // 返回 true 表示成功
      // ... 保存逻辑 ...
      return true;
  }

  int main() {
      save_data();  // 警告：忽略 [[nodiscard]] 函数的返回值
      if (save_data()) {  // 正确：使用返回值
          // ... 处理成功 ...
      }
      return 0;
  }
  ```


#### **3. `constexpr` lambda**
- **功能**：lambda 表达式可被标记为 `constexpr`，支持在 **编译期执行**（需满足 constexpr 函数要求）。

  ```cpp
  constexpr auto add = [](int a, int b) constexpr {
      return a + b;
  };

  int main() {
      constexpr int val = add(3, 4);  // 编译期计算为 7
      static_assert(val == 7);  // 编译期断言通过
      return 0;
  }
  ```


#### **4. 类模板参数推导（Class Template Argument Deduction, CTAD）**
- **功能**：编译器自动推导模板类的参数类型，无需显式指定（类似函数模板推导）。

  ```cpp
  #include <vector>
  #include <tuple>

  int main() {
      std::vector v{1, 2, 3};  // 推导为 std::vector<int>（C++17前需写 std::vector<int>）
      std::tuple t(1, "hello", 3.14);  // 推导为 std::tuple<int, const char*, double>
      return 0;
  }
  ```


### **C++17 核心特性思维导图**
```
C++17
├─ 语言核心
│  ├─ 结构化绑定（auto [a,b] = tuple/struct/array）
│  ├─ if/switch 初始化语句（if (auto p = get(); p) { ... }）
│  ├─ 折叠表达式（(... op args) 展开参数包）
│  └─ constexpr if（编译期条件分支）
├─ 标准库增强
│  ├─ std::string_view（轻量级字符串视图，无拷贝）
│  ├─ 并行算法（std::execution::par 加速排序/填充）
│  ├─ std::filesystem（文件系统操作）
│  ├─ std::optional（可能为空的值）
│  └─ std::variant（类型安全的联合体）
└─ 其他特性
   ├─ inline 变量（头文件全局变量）
   ├─ [[nodiscard]]（强制使用返回值）
   ├─ constexpr lambda（编译期 lambda）
   └─ 类模板参数推导（CTAD，如 vector v{1,2,3}）
```


### **学习建议**
C++17 的特性显著提升了 **代码简洁性**（结构化绑定、CTAD）、**安全性**（`optional`、`variant`）和 **性能**（并行算法、`string_view`）。重点掌握：
- **结构化绑定** 和 **折叠表达式** 简化复合类型操作与元编程；
- **`std::optional`/`std::variant`** 替代“魔法值”和原始 union；
- **`std::filesystem`** 统一跨平台文件操作；
- **并行算法** 和 **`string_view`** 在性能敏感场景的应用。

C++17 是“现代 C++”的集大成者，多数特性已被主流编译器支持（GCC 7+、Clang 5+、MSVC 2017+），建议在新项目中积极使用。
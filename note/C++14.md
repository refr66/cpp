C++14 是 C++11 的增量更新，专注于 **完善 C++11 的特性**、**提升开发效率** 和 **减少冗余代码**，同时保持与 C++11 的兼容性。以下是 C++14 的核心知识点汇总：


### **一、语言特性增强**
#### **1. `auto` 类型推导扩展**
- **C++11 限制**：`auto` 不能用于函数返回值类型推导（需显式尾随返回类型）。
- **C++14 改进**：支持 `auto` 作为函数返回值类型，编译器根据 return 语句推导类型：
  ```cpp
  // C++11 需显式尾随返回类型
  auto add(int a, int b) -> int { return a + b; }

  // C++14 直接用 auto 推导返回值
  auto add(int a, int b) { return a + b; }  // 推导为 int
  auto multiply(double a, double b) { return a * b; }  // 推导为 double
  ```
  **注意**：函数体内所有 return 语句的类型必须一致，否则推导失败。


#### **2. 泛型 lambda（Generic Lambdas）**
- **C++11 限制**：lambda 参数必须显式指定类型（如 `[](int x) { ... }`）。
- **C++14 改进**：支持用 `auto` 作为 lambda 参数类型，实现泛型 lambda（编译器自动推导参数类型）：
  ```cpp
  // 泛型 lambda：可接收任意类型参数
  auto sum = [](auto a, auto b) { return a + b; };

  sum(1, 2);          // 推导为 int + int，返回 3
  sum(3.14, 2.7);     // 推导为 double + double，返回 5.84
  sum(std::string("a"), std::string("b"));  // 返回 "ab"
  ```
  本质是编译器将泛型 lambda 转换为 **带模板 operator() 的函数对象**。


#### **3. 变量模板（Variable Templates）**
- **C++11 限制**：模板只能用于类和函数。
- **C++14 新增**：支持变量模板，定义泛型变量（如数学常量、全局配置）：
  ```cpp
  // 变量模板：不同类型的圆周率
  template <typename T>
  constexpr T pi = T(3.1415926535897932385);

  int main() {
      double d = pi<double>;   // 3.14159...
      float f = pi<float>;     // 3.14159f
      return 0;
  }
  ```
  常用于定义跨类型的常量或全局状态。


#### **4. `constexpr` 函数增强**
- **C++11 限制**：`constexpr` 函数体只能有 **单一 return 语句**，且不能包含循环、分支等复杂逻辑。
- **C++14 改进**：放松 `constexpr` 限制，允许：
  - 函数体包含 **循环**（`for`、`while`）、**条件语句**（`if`、`switch`）；
  - 局部变量（需初始化，且必须是 `constexpr` 类型）；
  - 多个 return 语句。

  ```cpp
  // C++14 constexpr 函数（支持循环和分支）
  constexpr int factorial(int n) {
      if (n < 0) return 0;  // 条件语句
      int res = 1;
      for (int i = 2; i <= n; ++i) {  // 循环
          res *= i;
      }
      return res;  // 多个 return 语句
  }

  constexpr int val = factorial(5);  // 编译期计算为 120（C++14 支持）
  ```


#### **5. `decltype(auto)`**
- **用途**：结合 `decltype` 和 `auto`，**自动推导表达式的类型**（保留引用/ cv 限定符），常用于函数返回值或变量声明。
- **解决问题**：C++11 中 `auto` 推导会忽略引用，而 `decltype(expr)` 可保留，但需显式写出表达式。`decltype(auto)` 自动根据初始化表达式的类型推导。

  ```cpp
  // 示例 1：函数返回值推导
  int x = 10;
  int& foo() { return x; }

  auto a = foo();          // a 是 int（引用被忽略）
  decltype(auto) b = foo();  // b 是 int&（保留引用类型）

  // 示例 2：泛型函数返回值完美转发
  template <typename F, typename... Args>
  decltype(auto) wrapper(F&& f, Args&&... args) {
      return std::forward<F>(f)(std::forward<Args>(args)...);  // 保留 f 返回值类型
  }
  ```


### **二、库特性增强**
#### **1. `std::make_unique`**
- **C++11 缺失**：标准库提供了 `std::make_shared`（安全创建 `shared_ptr`），但未提供 `std::make_unique`。
- **C++14 新增**：`std::make_unique`（位于 `<memory>`），避免直接使用 `new`，更安全（防止内存泄漏）且代码简洁：
  ```cpp
  // C++11 创建 unique_ptr（需显式 new）
  std::unique_ptr<int> p1(new int(10));

  // C++14：使用 make_unique（推荐，异常安全）
  std::unique_ptr<int> p2 = std::make_unique<int>(10);
  std::unique_ptr<std::vector<int>> p3 = std::make_unique<std::vector<int>>(3, 1);  // 初始化 vector{1,1,1}
  ```


#### **2. 数字分隔符（Digit Separators）**
- **语法**：允许用 **单引号 `'`** 分隔数字字面量，增强可读性（不影响数值）：
  ```cpp
  int million = 1'000'000;       // 等价于 1000000
  double pi = 3.1415'9265'3589;  // 增强可读性
  uint64_t big_num = 0x1234'5678'9ABC'DEF0;  // 十六进制同样支持
  ```


#### **3. `std::exchange`**
- **功能**：将对象的值替换为新值，并返回 **旧值**（原子操作，避免临时变量）：
  ```cpp
  #include <utility>  // std::exchange

  int main() {
      int x = 10;
      int old = std::exchange(x, 20);  // x 变为 20，old 为 10
      return 0;
  }

  // 实用场景：移动语义中替换指针
  class MyClass {
      std::string data;
  public:
      std::string take_data() {
          return std::exchange(data, {});  // 返回旧 data，将 data 置为空字符串
      }
  };
  ```


#### **4. `std::integer_sequence` 与编译期整数序列**
- **功能**：表示编译期整数序列（如 `std::integer_sequence<int, 0, 1, 2>`），常用于 **元编程**（如展开参数包）：
  ```cpp
  #include <utility>  // std::integer_sequence, std::make_integer_sequence

  // 打印整数序列（递归展开）
  template <int... Ints>
  void print(std::integer_sequence<int, Ints...>) {
      ((std::cout << Ints << " "), ...);  // C++17 折叠表达式（C++14 可用递归）
  }

  int main() {
      print(std::make_integer_sequence<int, 5>());  // 输出：0 1 2 3 4
      return 0;
  }
  ```
  是实现 `std::tuple` 遍历、参数包展开的基础工具。


#### **5. `std::shared_timed_mutex` 与读写锁**
- **新增**：`std::shared_timed_mutex`（位于 `<shared_mutex>`），支持 **读写分离锁**：
  - 多个线程可同时获取 **读锁**（共享锁）；
  - 仅一个线程可获取 **写锁**（排他锁），且写锁与读锁互斥。
  比 `std::mutex` 更高效（适合读多写少场景）：
  ```cpp
  #include <shared_mutex>

  std::shared_timed_mutex mtx;
  int data = 0;

  // 读操作（共享锁）
  int read_data() {
      std::shared_lock<std::shared_timed_mutex> lock(mtx);  // 读锁
      return data;
  }

  // 写操作（排他锁）
  void write_data(int new_val) {
      std::unique_lock<std::shared_timed_mutex> lock(mtx);  // 写锁
      data = new_val;
  }
  ```


### **三、其他小特性**
#### **1. `[[deprecated]]` 属性**
- **功能**：标记函数、类或变量为 **已过时**，编译器会在使用时发出警告：
  ```cpp
  [[deprecated("use new_func() instead")]]
  void old_func() {}

  int main() {
      old_func();  // 编译警告：'old_func' is deprecated: use new_func() instead
      return 0;
  }
  ```


#### **2. 二进制字面量**
- **C++11 支持**：十六进制（`0x`）、八进制（`0`）字面量。
- **C++14 新增**：二进制字面量（前缀 `0b` 或 `0B`）：
  ```cpp
  int flag = 0b1010;  // 二进制 1010，即十进制 10
  ```


#### **3. `std::get` 支持异质 tuple 访问（C++11 已部分支持，C++14 完善）**
- **功能**：通过 **类型** 获取 `std::tuple` 中的元素（需保证类型唯一）：
  ```cpp
  #include <tuple>
  #include <string>

  int main() {
      std::tuple<int, std::string, double> t(1, "hello", 3.14);
      int x = std::get<int>(t);          // 获取 int 类型元素（1）
      std::string s = std::get<std::string>(t);  // 获取 string 类型元素（"hello"）
      return 0;
  }
  ```


### **C++14 与 C++11 的核心差异总结**
| **特性**               | **C++11**                                  | **C++14**                                  |
|------------------------|-------------------------------------------|-------------------------------------------|
| `auto` 返回值          | 不支持（需尾随返回类型）                   | 支持 `auto` 推导函数返回值                |
| 泛型 lambda            | 不支持（参数需显式类型）                   | 支持 `auto` 参数，实现泛型 lambda         |
| `constexpr` 函数       | 仅单 return 语句，无循环/分支              | 支持循环、分支、局部变量，更灵活          |
| `std::make_unique`     | 缺失（需手动 `new`）                       | 新增，安全创建 `unique_ptr`               |
| 变量模板               | 不支持                                     | 支持模板变量（如 `template <typename T> T pi;`） |
| 数字分隔符             | 不支持                                     | 支持 `'` 分隔数字（如 `1'000'000`）        |


### **学习建议**
C++14 的特性相对“轻量”，但极大提升了 **编码效率**（如泛型 lambda、`auto` 返回值）和 **元编程能力**（如 `constexpr` 增强、`integer_sequence`）。学习时建议结合 C++11 特性一起掌握，重点关注：
- **`auto` 和 `decltype(auto)`** 在返回值推导中的应用；
- **泛型 lambda** 简化函数对象（如 STL 算法中的自定义比较器）；
- **`constexpr` 函数** 从“玩具”变为实用的编译期计算工具；
- **`std::make_unique`** 替代 `new`，养成安全的内存管理习惯。

C++14 是向“现代 C++”过渡的重要一步，为后续 C++17 的大幅扩展（如结构化绑定、折叠表达式）奠定了基础。